format MZ
push cs 				    
pop ds					    ;Инициализация сегмента данных
push ds
pop ss					      ;Инициализация сегмента стека
jmp mt1 				     ;Переход на основную программу
  macro out_str str		  ;Вывод текстового сообщения
	    {
	      mov dx,str
	      mov ah,9
	      int 21h
	     }

  macro cursor		   ;Перевод экранного курсора монитора
	    { mov ah,2
	      mov dl,0dh
	      int 21h
	      mov dl,0ah
	      int 21h }
  macro scr_ddw adr		   ;Вывод на экран пакета байтов
	{
	local nxt
	mov si,adr		     ;Начальный адрес пакета
	add si,7		       ;Конечный адрес пакета
	mov cx,8		     ;Ёмкость пакета в восемь байт
	  nxt:scr_byt			     ;Вывод на экран текущего байта двоичным кодом   
	dec si				;Адрес младшего байта пакета  
	loop  nxt		      ;Переход на вывод следующего байта
	cursor			       ;Перевод экранного курсора в начало новой строки   
	}

  macro scr_byt 		    ;Вывод одного байта
	{
	local tst,w_0,w_1	  
	mov bl,128		      ;Тестовая маска
	mov ah,2		       ;Функция DOS прерывания вывода  
	   tst:test [si],bl			  ;Конъюнктивная маска в памяти  
	jz w_0				 ;Тестируемый бит равен нулю
	mov dl,'1'			; Для вывода единицы
	jmp w_1    
	w_0:mov dl,'0'			     ; Для вывода нуля          
	w_1:int 21h			       ; Ввывод на экран бита 
	shr bl,1			   ;Сдвиг единицы маски вправо 
	jne tst 			    ;Повторить тестирование
	mov dl,' '			  ;Для вывода пробела          
	int 21h 			   ;Вывод пробела         
	}

  macro inp_dat ope		      ;Ввод данных с клавиатуры
	{local lpp,rpt,s30,cor,sto
	mov ah,7			;Функция DOS прерывания ввода  
	mov bx,ope		      ;Начальный адрес вводимого пакета байтов
	add bx,7			 ;Конечный адрес вводимого пакета байтов
	mov dh,8			;Число  вводимых байтов пакета
	  lpp:mov dl,2			       ;Число тетрад в байте пакета
	   rpt:int 21h				  ;Ожидание нажатия клавиши
	cmp al,30h			;Сравнение с граничным кодом символа 
	jb rpt				    ;Введенный символ ниже границы 
	cmp al,3ah		       ;Сравнение с границей, следующей за концом числового символа    
	jb s30				  ; Введенный символ есть число 0,1, .. , 9 в формате ASCII
	cmp al,61h		       ;Сравнение с границей начала символа a
	jb rpt						       ;Введенный символ вне рабочего диапазона
	cmp al,67h					  ;Сравнение с границей за концом символа f
	jnb rpt 					     ;Введенный символ вне рабочего диапазона
	sym						     ;Введенный символ есть буква a, b, .., f в формате ASCII, которая выводится
	sub al,57h					   ;Перерасчёт на представление символа в младшей тетраде
	jmp cor 					    ;Переход на коррекцию байта  
	 s30:sym				 ;Вывод сервисом  DOS символа на экран
	sub al,30h			 ;Устранение в коде символа избытка
	  cor:dec dl				 ;Уменшение числа тетрад в байте
	je sto				    ;Байт обработан
	mov cl,4			 ;Число разрядов в тетраде    
	shl al,cl			    ;Передача из младшей в старшую тетраду 
	mov [bx],al			;Пересылка байта с заполненной старшей тетрадой
	jmp rpt 			  ;Переход на обрабтку младшей тетрады
	  sto:add [bx],al		       ;Соединение тетрад в байте
	push ax 			;Вывод
	push dx 			;на экран
	mov ah,2		       ;монитора  
	mov dl,' '			 ;средствами  
	int 21h 			  ;сервиса DOS
	pop dx				;симола
	pop ax				;пробел
	dec bx				;Коррекция адреса памяти   
	dec dh				;Коррекция числя байтов   
	jne lpp 			 ;Обработаны не все байты пакета      
	cursor} 				      ;Перевод экранного курсора в начало новой строки    
  macro sym			  ;Вывод ASCII символа на экран
       {
       push ax
       push dx
       mov ah,2
       mov dl,al
       int 21h
       pop dx
       pop ax
       }
  macro add_b		 ;Эмуляция сложения  с переполнением
  {
       local ckl
       mov si,Opr_X	       ;Инициализация 
       mov di,Opr_Y	       ;адресных   
       mov bx,Prd		 ;регистров
       mov cx,8 		   ;и счётчика 
 ckl:mov al, [si]		   ;Байт операнда X
       add al, [di]		     ;Сложение с байтом оперкнда Y
       mov [bx], al		   ;Результат сложения
      inc si				;Коррекция 
      inc di				;адресных 
      inc bx			       ;регистров
      loop ckl			      ;и счётчика      
       }
 
      macro add_ub		 ;Эмуляция сложения  с беззнаковым насыщением
   {
       local ckl,nof
       mov si,Opr_X
       mov di,Opr_Y
       mov bx,Prd
       mov cx,8   
 ckl:mov al, [si]
      add al, [di] 
      jnc nof				 ;Беззнакового насыщения нет
      mov al,255		      ;Число, равное беззнаковому насыщению
nof:mov [bx], al
      inc si
      inc di
      inc bx
      loop ckl
       }
  macro add_sb			   ;Эмуляция сложения со знаковым насыщением
   {
       local ckl,nof, p7f   
       mov si,Opr_X
       mov di,Opr_Y
       mov bx,Prd
      mov cx,8
 ckl:mov al, [si]
      add al, [di]			   
      jno nof		    ;Знакового насыщения нет                  
      js p7f				 ;Есть знаковое положительное насыщение
      mov al, $80		     ;Число, равное знаковому отрицательному насыщению
      jmp nof			       ;Переход на загрузку памяти
p7f:mov al, $7f 		    ;Число, равное знаковому положительному насыщению
nof:mov [bx], al
      inc si
      inc di
      inc bx
      loop ckl
       }
 mt1:				    ;Начало основной программы Opr_x:=Opr_x + Opr_y
 out_str mes1		       ;Вывод на экран текстового сооббщения
   cursor			   ;Перевод экранного курсора в начало новой строки
 out_str mes2		       ;Вывод на экран текстового сооббщения
   cursor			   ;Перевод экранного курсора в начало новой строки
 scr_ddw Opr_X		   ;Вывод на экран двоичным кодом пакета Opr_X
   cursor			   ;Перевод экранного курсора в начало новой строки   
 out_str mes3		       ;Вывод на экран текстового сооббщения
 out_str mes5		       ;Вывод на экран текстового сооббщения
   cursor			   ;Перевод экранного курсора в начало новой строки 
 inp_dat Opr_Y		     ;Ввод с клавиатуры шестнадцатеричным кодом пакета Opr_Y
   cursor			   ;Перевод экранного курсора в начало новой строки
 scr_ddw Opr_Y		   ;Вывод на экран двоичным кодом пакета Opr_Y  
  cursor			   ;Перевод экранного курсора в начало новой строки
add_b			      ;Эмуляция пакетного сложения с циклическим переполнением   
;add_ub                     ;Эмуляция пакетного сложения с беззнаковым насыщением  
;add_sb             ;Эмуляция пакетного сложения со знаковым насыщением 
mov edx,Opr_X		  ;Загрузка адреса в  регистр                 
movq mm0,[edx]	     ;MOVe Quarter word to MMX0                    
mov edx,Opr_Y		  ;Загрузка адреса в  регистр   
movq mm7,[edx]		  ;MOVe Quarter word to MMX0    
paddb mm0,mm7	   ;Packed ADDitin Bytes   MMX0:=(MMX0) +(MMX7)       
;paddusb mm0,mm7       ;Packed ADDitin Unsigned with Saturation Bytes    MMX0:=(MMX0) +(MMX7)   
;paddsb mm0,mm7        ;Packed ADDitin signed with Saturation Bytes    MMX0:=(MMX0) +(MMX7)    
movq [edx],mm0	      ;MOVe Quarter word to M[edx] 
out_str mes4		     ;Вывод на экран текстового сооббщения       
 cursor 			 ;Перевод экранного курсора в начало новой строки
  scr_ddw Opr_Y 		      ;Вывод на экран двоичным кодом пакета суммы  
   cursor			 ;Перевод экранного курсора в начало новой строки
out_str mes7		;Вывод на экран текстового сооббщения 
  cursor			;Перевод экранного курсора в начало новой строки
scr_ddw Prd		;Вывод на экран двоичным кодом пакета суммі ємулятора
cursor			 ;Перевод экранного курсора в начало новой строки
out_str mes6		 ;Вывод на экран текстового сооббщения  
exit:				;Возврат в системную операционную среду
mov ax, 4c00h	   
int 21h 			   
Opr_X dq  67a540dcee49b31fh ;Определение в памяти первого операнда Х
Opr_Y db 8 dup (?)  ;Резервирование в памяти места под второй, читаемый с клавиатуры операнд Y    
Prd	 db 8 dup (?)  ;Резервирование в памяти места под сумму, полученную при эмуляции сложения
	mes1 db '           TECHNOLOGI MMX ADDITION THE PENTIUM PROCESSOR ',0ah,0dh,'$'
	mes2 db '                              Operand X',0ah,0dh,'$'
	mes3 db '                              Operand Y',0ah,0dh,'$'
	mes4 db '                              Resultat Z',0ah,0dh,'$'
	mes5 db '                           Introduse the key',0ah,0dh,'$'
	mes6 db '                                Finish',0ah,0dh,'$'
	mes7 db '                   Testing Packed Addition Bytes',0ah,0dh,'$'
		
	 
;Packed Addition with Unsigned Saturation Bytes (PADDUSB)
;01100111 10100101 01000000 11011100 11101110 01001001 10110011 00011111
;10101010 00110000 01011111 11010011 11001100 10100000 10011111 00101000
;_______________________________________________________________
;11111111 11010101 10011111 11111111 11111111 11101001 11111111 01000111
	
;Packed Addition with signed Saturation Bytes (PADDSB)
;01100111 10100101 01000000 11011100 11101110 01001001 10110011 00011111
;01010110 10101101 00110000 01110001 11110110 01101010 11011101 11000101
;_______________________________________________________________
;01111111 10000000 01110000 01001101 11100100 01111111 10010000 11100100




